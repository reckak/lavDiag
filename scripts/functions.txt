#' Assert that `fit` is a usable lavaan/blavaan model
#'
#' @param fit A fitted lavaan/blavaan object.
#' @param require_converged logical; if TRUE, fail on non-converged models.
#' @param require_meanstructure logical|NA; TRUE = must have meanstructure,
#'        FALSE = must NOT have meanstructure, NA = don't check.
#' @param require_latent logical; if TRUE, require at least one latent variable.
#' @return Invisibly returns NULL if all checks pass; otherwise `stop()`.
#' @noRd
.assert_lavaan_fit <- function(fit,
                               require_converged   = TRUE,
                               require_meanstructure = NA,
                               require_latent      = FALSE) {
  # -- Class check -------------------------------------------------------------
  if (!inherits(fit, "lavaan")) {
    cls <- paste(class(fit), collapse = ", ")
    stop("`fit` must be a fitted lavaan/blavaan object; received: ", cls,
         call. = FALSE)
  }

  # -- Convergence -------------------------------------------------------------
  if (isTRUE(require_converged)) {
    conv <- tryCatch(lavaan::lavInspect(fit, "converged"),
                     error = function(e) NA)
    if (!isTRUE(conv)) {
      msg <- tryCatch(lavaan::lavInspect(fit, "optim")$message,
                      error = function(e) NULL)
      if (is.null(msg) || !nzchar(msg)) msg <- "Model did not converge."
      stop("lavaan convergence check failed: ", msg, call. = FALSE)
    }
  }

  # -- Meanstructure (optional) -----------------------------------------------
  if (!is.na(require_meanstructure)) {
    has_mean <- isTRUE(tryCatch(lavaan::lavInspect(fit, "meanstructure"),
                                error = function(e) FALSE))
    if (require_meanstructure && !has_mean) {
      stop("Model was not fitted with meanstructure = TRUE, but it is required.",
           call. = FALSE)
    }
    if (!require_meanstructure && has_mean) {
      stop("Model has meanstructure = TRUE, but it is not expected here.",
           call. = FALSE)
    }
  }

  # -- At least one latent variable (optional) --------------------------------
  if (isTRUE(require_latent)) {
    lv <- tryCatch(lavaan::lavNames(fit, "lv"),
                   error = function(e) character())
    if (length(lv) == 0L) {
      stop("No latent variables detected in `fit`, but at least one is required.",
           call. = FALSE)
    }
  }

  invisible(NULL)
}

#' Assert that measurement parameters needed for predictions exist
#' (i.e., Lambda loadings and optionally intercepts)
#' @noRd
.assert_has_measurement <- function(fit, need_intercepts = FALSE) {
  L <- tryCatch(lavaan::lavInspect(fit, "lambda"),
                error = function(e) NULL)
  if (is.null(L)) {
    stop("Cannot extract loadings (Lambda) via lavInspect(fit, 'lambda').",
         call. = FALSE)
  }
  if (is.matrix(L)) L <- list(L)  # homogenize single-group to list
  ok <- vapply(L, function(M) is.matrix(M) && nrow(M) > 0 && ncol(M) > 0, TRUE)
  if (!all(ok)) stop("Loading matrix (Lambda) has zero rows/cols for some group.", call. = FALSE)

  if (isTRUE(need_intercepts)) {
    nu <- tryCatch(lavaan::lavInspect(fit, "nu"),
                   error = function(e) NULL)
    if (is.null(nu)) {
      stop("Intercepts (nu) are required but not available. Fit with meanstructure = TRUE.",
           call. = FALSE)
    }
  }
  invisible(NULL)
}




#' Check if a lavaan model is single-group
#'
#' This helper function checks whether a fitted \code{lavaan} model
#' contains only a single group.
#'
#' @param fit An object of class \code{lavaan}.
#'
#' @return Logical scalar. Returns \code{TRUE} if the model has only
#'   one group, \code{FALSE} otherwise.
#'
#' @noRd
#' @keywords internal
.is_single_group <- function(fit) {
  # -- Validate input ----------------------------------------------------------
  .assert_lavaan_fit(fit)

  # -- Primary: use ngroups from lavInspect (most reliable) --------------------
  ng <- tryCatch(lavaan::lavInspect(fit, "ngroups"),
                 error = function(e) NA_integer_)

  if (!is.na(ng)) return(ng <= 1L)

  # -- Fallback: use group labels if ngroups unavailable -----------------------
  gl <- tryCatch(lavaan::lavInspect(fit, "group.label"),
                 error = function(e) NULL)

  if (!is.null(gl)) return(length(gl) <= 1L)

  # -- Conservative default: assume single-group if inspection failed ----------
  TRUE
}


#' Summarize basic model properties from a lavaan/blavaan fit
#'
#' @param fit A fitted lavaan or blavaan object.
#' @return A named list with model properties (groups, categorical, multilevel, etc.).
#' @examples
#' # info <- model_info(fit)
model_info <- function(fit) {
  # -- Defensive check ---------------------------------------------------------
  .assert_lavaan_fit(fit)

  # -- Groups ------------------------------------------------------------------
  n_groups <- tryCatch(lavaan::lavInspect(fit, "ngroups"), error = function(e) NA_integer_)
  is_single_group <- isTRUE(n_groups == 1L)

  # -- Categorical -------------------------------------------------------------
  is_categorical <- tryCatch(lavaan::lavInspect(fit, "categorical"),
                             error = function(e) NA)

  # -- Variables ---------------------------------------------------------------
  observed_variables <- tryCatch(lavaan::lavNames(fit, type = "ov"),
                                 error = function(e) character())
  latent_variables   <- tryCatch(lavaan::lavNames(fit, type = "lv"),
                                 error = function(e) character())

  # -- Group meta --------------------------------------------------------------
  group_labels <- tryCatch(lavaan::lavInspect(fit, "group.label"),
                           error = function(e) NULL)
  n_obs        <- tryCatch(lavaan::lavInspect(fit, "nobs"),
                           error = function(e) NULL)

  # -- Multilevel detection ----------------------------------------------------
  # Use public inspectors documented in lavaan manual:
  # - "nlevels": number of levels (>=2 implies multilevel)
  # - "cluster": name(s) of clustering variable(s) if specified
  n_levels <- tryCatch(lavaan::lavInspect(fit, "nlevels"),
                       error = function(e) NA_integer_)
  cluster_var <- tryCatch(lavaan::lavInspect(fit, "cluster"),
                          error = function(e) NULL)
  n_clusters <- tryCatch(lavaan::lavInspect(fit, "nclusters"),
                         error = function(e) NA_integer_)
  avg_cluster_size <- tryCatch(lavaan::lavInspect(fit, "average.cluster.size"),
                               error = function(e) NA_real_)

  is_multilevel <- isTRUE(!is.na(n_levels) && n_levels >= 2L) ||
    (!is.null(cluster_var) && length(cluster_var) > 0L)


  list(
    is_single_group    = is_single_group,
    is_categorical     = is_categorical,
    observed_variables = observed_variables,
    latent_variables   = latent_variables,
    group_labels       = group_labels,
    n_obs              = n_obs,
    n_groups           = n_groups,
    # --- multilevel summary ---
    is_multilevel      = is_multilevel,
    n_levels           = n_levels,
    cluster_var        = cluster_var,
    n_clusters         = n_clusters,
    average_cluster_size = avg_cluster_size
  )
}



