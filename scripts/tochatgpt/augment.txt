#' Augment SEM data with latent predictions, residuals, and (optional) CIs
#'
#' Public user-facing wrapper that augments fitted `lavaan` models with predicted
#' values, residuals, optional delta-method SEs/CIs, and (for ordinal models) also
#' latent linear predictors (y*) and per-category probabilities. Supports
#' continuous-only, ordinal-only, and mixed (both types) models.
#'
#' Internally routes to `.augment_continuous()` and/or `.augment_ordinal()` and
#' reuses `data` (lavPredict output) and `info` (model_info) so they are computed
#' at most once.
#'
#' @param fit A fitted `lavaan` object.
#' @param data Optional lavPredict output to reuse. Either a data.frame (single-group)
#'   or a list of data.frames (per group) as returned by `lavPredict_parallel()`.
#'   If `NULL`, it will be computed once and reused.
#' @param info Optional `model_info(fit)` list to reuse. If `NULL`, it will be computed.
#' @param # ---- Common toggles ----
#' @param yhat Logical; include predicted observed values (default TRUE).
#' @param resid Logical; include residuals (obs - yhat) (default TRUE).
#' @param ci Logical; include delta-method CIs for `yhat` (default TRUE).
#' @param level CI level (default 0.95).
#' @param se_yhat Logical; include delta-method SEs of `yhat` (default TRUE).
#' @param # ---- Ordinal-only toggles ----
#' @param ystar Logical; include latent linear predictors y* for ordinal items (default TRUE).
#' @param pr Logical; include per-category probabilities for ordinal items (default TRUE).
#' @param # ---- Factor-score SEs (continuous-only) ----
#' @param se_fs Logical; request factor-score SEs in `lavPredict_parallel()` for continuous-only
#'   models (default TRUE). Ignored when any ordinal indicator is present.
#' @param vcov_type Optional `vcov()` type passed to the continuous branch for robust CIs.
#' @param # ---- Column prefixes ----
#' @param prefix_ystar,prefix_yhat,prefix_pr,prefix_ci,prefix_resid,
#'   prefix_se_fs,prefix_se_yhat Character prefixes for generated columns. Must be consistent
#'   with the internal augmenters' expectations (defaults mirror internal functions).
#'
#' @return A tibble-like `data.frame` with `.rid`, `.gid`, `.group`, original lavPredict
#'   columns (observed, factor scores, and FS SEs if requested/available) and appended
#'   augmentation columns from the relevant branches.
#'
#' @export
augment <- function(fit,
                    data            = NULL,
                    info            = NULL,
                    # common toggles
                    yhat            = TRUE,
                    resid           = TRUE,
                    ci              = TRUE,
                    level           = 0.95,
                    se_yhat         = TRUE,
                    # ordinal-only toggles
                    ystar           = TRUE,
                    pr              = TRUE,
                    # FS SEs (cont-only)
                    se_fs           = TRUE,
                    vcov_type       = NULL,
                    # NEW: column layout selector
                    col_layout      = c("by_type", "by_item"),
                    # prefixes (kept aligned with internals)
                    prefix_ystar    = ".ystar_",
                    prefix_yhat     = ".yhat_",
                    prefix_pr       = ".pr_",
                    prefix_ci       = c(".yhat_lwr_", ".yhat_upr_"),
                    prefix_resid    = ".resid_",
                    prefix_se_fs    = ".se_",
                    prefix_se_yhat  = ".se_yhat_",
                    sep             = "__") {

  col_layout <- match.arg(col_layout)

  # -- Assertions on fit (light; internals do strict checks) -------------------
  .assert_lavaan_fit(fit)

  # -- One-time model info -----------------------------------------------------
  if (is.null(info)) info <- model_info(fit)
  ov_all  <- info$observed_variables
  ov_cont <- info$ov_continuous
  ov_ord  <- info$ov_ordinal
  lats    <- info$latent_variables

  # -- One-time lavPredict data (reused) ---------------------------------------
  if (is.null(data)) {
    request_fs_se <- isTRUE(se_fs) && length(ov_ord) == 0L
    data <- lavPredict_parallel(
      fit,
      return_type  = "list",
      se           = request_fs_se,
      prefix_se_fs = prefix_se_fs
    )
  }

  # --- Helper: column ordering ------------------------------------------------
  # In English: Reorder columns into a tidy layout.
  .reorder_augmented_columns <- function(df, layout, info,
                                         prefix_ystar, prefix_yhat, prefix_ci,
                                         prefix_resid, prefix_se_fs, prefix_se_yhat,
                                         prefix_pr, sep) {

    # 0) Core anchors ----------------------------------------------------------
    core <- c(".rid", ".gid", ".group")
    core <- core[core %in% names(df)]

    # 1) Factor scores + their SEs --------------------------------------------
    lats <- info$latent_variables
    fs_cols    <- lats[lats %in% names(df)]
    fs_se_cols <- paste0(prefix_se_fs, fs_cols)
    fs_se_cols <- fs_se_cols[fs_se_cols %in% names(df)]

    # 2) Items to consider (observed variable names in model order) ------------
    items_model <- info$observed_variables
    items <- items_model[items_model %in% names(df) |
                           paste0(prefix_yhat, items_model) %in% names(df) |
                           paste0(prefix_ystar, items_model) %in% names(df) |
                           paste0(prefix_resid, items_model) %in% names(df) |
                           paste0(prefix_se_yhat, items_model) %in% names(df)]

    # Helper to safely keep existing columns only
    keep_existing <- function(x) x[x %in% names(df)]

    # 3) Build lists of columns by item / by type ------------------------------
    # Per-item collector (observed first, then generated in a stable order)
    collect_for_item <- function(j) {
      pr_regex <- paste0("^", gsub("([.\\+*?\\^$\\(\\)\\[\\]\\{\\}\\|\\\\])", "\\\\\\1", prefix_pr),
                         ".*", gsub("([.\\+*?\\^$\\(\\)\\[\\]\\{\\}\\|\\\\])", "\\\\\\1", sep),
                         j, "$")
      c(
        keep_existing(j),
        keep_existing(paste0(prefix_ystar,    j)),
        keep_existing(paste0(prefix_yhat,     j)),
        keep_existing(paste0(prefix_ci[1L],   j)),
        keep_existing(paste0(prefix_ci[2L],   j)),
        keep_existing(paste0(prefix_se_yhat,  j)),
        keep_existing(paste0(prefix_resid,    j)),
        grep(pr_regex, names(df), value = TRUE)
      )
    }

    # By-type collector: for each type, all items in model order
    collect_by_type <- function(prefix, suffix_fun = identity) {
      cols <- unlist(lapply(items, function(j) paste0(prefix, suffix_fun(j))), use.names = FALSE)
      keep_existing(cols)
    }
    # 'pr' by-type: preserve category order as in names(df)
    collect_pr_by_type <- function() {
      # all pr_* columns, but order them grouped by item
      pr_all <- grep(paste0("^", gsub("([.\\+*?\\^$\\(\\)\\[\\]\\{\\}\\|\\\\])","\\\\\\1", prefix_pr)), names(df), value = TRUE)
      out <- character(0)
      for (j in items) {
        rx <- paste0(prefix_pr, ".*", sep, j, "$")
        out <- c(out, grep(rx, pr_all, value = TRUE))
      }
      out
    }

    # 4) Build the middle block according to layout ----------------------------
    middle <- switch(layout,
                     "by_item" = unlist(lapply(items, collect_for_item), use.names = FALSE),
                     "by_type" = c(
                       keep_existing(items),  # raw observed items first
                       collect_by_type(prefix_ystar),
                       collect_by_type(prefix_yhat),
                       collect_by_type(prefix_ci[1L]),
                       collect_by_type(prefix_ci[2L]),
                       collect_by_type(prefix_se_yhat),
                       collect_by_type(prefix_resid),
                       collect_pr_by_type()
                     )
    )

    # 5) Anything leftover (unknown extras) goes to the end --------------------
    front <- c(core, fs_cols, fs_se_cols)
    known <- unique(c(front, middle))
    tail  <- setdiff(names(df), known)

    new_order <- c(front, middle, tail)
    df[, new_order, drop = FALSE]
  }

  # -- Routing by measurement type --------------------------------------------
  has_cont <- length(ov_cont) > 0L
  has_ord  <- length(ov_ord)  > 0L

  if (!has_cont && !has_ord) {
    stop("The fitted model has neither continuous nor ordinal observed indicators.", call. = FALSE)
  }

  if (has_cont && !has_ord) {
    out <- .augment_continuous(
      fit            = fit,
      data           = data,
      info           = info,
      yhat           = yhat,
      ci             = ci,
      level          = level,
      resid          = resid,
      se_fs          = se_fs,
      se_yhat        = se_yhat,
      prefix_yhat    = prefix_yhat,
      prefix_ci      = prefix_ci,
      prefix_resid   = prefix_resid,
      prefix_se_fs   = prefix_se_fs,
      prefix_se_yhat = prefix_se_yhat,
      vcov_type      = vcov_type
    )
    # Reorder here before returning
    out <- .reorder_augmented_columns(out, col_layout, info,
                                      prefix_ystar, prefix_yhat, prefix_ci,
                                      prefix_resid, prefix_se_fs, prefix_se_yhat,
                                      prefix_pr, sep)
    return(out)
  }

  if (!has_cont && has_ord) {
    out <- .augment_ordinal(
      fit            = fit,
      data           = data,
      info           = info,
      ystar          = ystar,
      yhat           = yhat,
      pr             = pr,
      ci             = ci,
      level          = level,
      resid          = resid,
      se_yhat        = se_yhat,
      prefix_ystar   = prefix_ystar,
      prefix_yhat    = prefix_yhat,
      prefix_pr      = prefix_pr,
      prefix_ci      = prefix_ci,
      prefix_resid   = prefix_resid,
      prefix_se_yhat = prefix_se_yhat,
      sep            = sep
    )
    out <- .reorder_augmented_columns(out, col_layout, info,
                                      prefix_ystar, prefix_yhat, prefix_ci,
                                      prefix_resid, prefix_se_fs, prefix_se_yhat,
                                      prefix_pr, sep)
    return(out)
  }

  # Mixed (both continuous and ordinal)
  aug_cont <- .augment_continuous(
    fit            = fit,
    data           = data,
    info           = info,
    yhat           = yhat,
    ci             = ci,
    level          = level,
    resid          = resid,
    se_fs          = se_fs,
    se_yhat        = se_yhat,
    prefix_yhat    = prefix_yhat,
    prefix_ci      = prefix_ci,
    prefix_resid   = prefix_resid,
    prefix_se_fs   = prefix_se_fs,
    prefix_se_yhat = prefix_se_yhat,
    vcov_type      = vcov_type
  )
  aug_ord <- .augment_ordinal(
    fit            = fit,
    data           = data,
    info           = info,
    ystar          = ystar,
    yhat           = yhat,
    pr             = pr,
    ci             = ci,
    level          = level,
    resid          = resid,
    se_yhat        = se_yhat,
    prefix_ystar   = prefix_ystar,
    prefix_yhat    = prefix_yhat,
    prefix_pr      = prefix_pr,
    prefix_ci      = prefix_ci,
    prefix_resid   = prefix_resid,
    prefix_se_yhat = prefix_se_yhat,
    sep            = sep
  )

  # Split base vs augmentation parts (unchanged)
  split_base_aug <- function(df) {
    aug_prefixes <- c(prefix_ystar, prefix_yhat, prefix_pr, prefix_resid, prefix_se_yhat,
                      prefix_ci[1L], prefix_ci[2L])
    starts_with_any <- function(nm, pref) any(startsWith(nm, pref))
    is_aug <- vapply(names(df), starts_with_any, logical(1L), pref = aug_prefixes)
    list(base = df[, !is_aug, drop = FALSE],
         aug  = df[,  is_aug, drop = FALSE])
  }
  sbc <- split_base_aug(aug_cont)
  sbo <- split_base_aug(aug_ord)

  base <- sbc$base
  if (all(c(".rid", ".gid") %in% names(base)) &&
      all(c(".rid", ".gid") %in% names(sbo$base))) {
    key_base <- paste0(base$.rid, "_", base$.gid)
    key_ord  <- paste0(sbo$base$.rid, "_", sbo$base$.gid)
    idx <- match(key_base, key_ord)
    if (!all(!is.na(idx) & idx == seq_along(idx))) {
      sbo$aug <- sbo$aug[idx, , drop = FALSE]
    }
  }
  dup_cols <- intersect(names(sbc$aug), names(sbo$aug))
  if (length(dup_cols)) sbo$aug <- sbo$aug[, setdiff(names(sbo$aug), dup_cols), drop = FALSE]

  out <- cbind(base, sbc$aug, sbo$aug, stringsAsFactors = FALSE)
  class(out) <- c("tbl_df", "tbl", "data.frame")

  # Final tidy column order
  out <- .reorder_augmented_columns(out, col_layout, info,
                                    prefix_ystar, prefix_yhat, prefix_ci,
                                    prefix_resid, prefix_se_fs, prefix_se_yhat,
                                    prefix_pr, sep)
  out
}
