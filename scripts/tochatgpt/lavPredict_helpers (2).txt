# -------- Helpers for dummy rows -------------------------------------------

# Use your existing "all categories per ordinal per group" dummy builder
# (ensures each ordinal has all categories in each group).
# Source: create_dummy_from_original() in your codebase.
create_allcat_dummy <- function(df, ord_vars, group_var = NULL) {
  create_dummy_from_original(df, ord_vars, group_var = group_var)
}

# NEW: variance-insurance dummy for continuous variables
# Ensures that, within each group, every continuous variable has at least
# two distinct valid values present in the chunk (to avoid zero variance).
create_continuous_variance_dummy <- function(df, cont_vars, group_var = NULL) {
  if (!length(cont_vars)) return(df[0, , drop = FALSE])

  build_for_group <- function(dg) {
    if (nrow(dg) == 0L) return(dg[0, , drop = FALSE])
    proto <- dg[1, , drop = FALSE]
    rows  <- list()
    for (v in cont_vars) {
      if (!v %in% names(dg)) next
      x <- dg[[v]]
      # pick two distinct, finite values
      ux <- unique(x[is.finite(as.numeric(x)) & !is.na(x)])
      if (length(ux) < 2L) next
      vals <- ux[1:2]
      r1 <- proto; r1[[v]] <- .cast_like(vals[1], x)
      r2 <- proto; r2[[v]] <- .cast_like(vals[2], x)
      rows[[length(rows) + 1L]] <- r1
      rows[[length(rows) + 1L]] <- r2
    }
    if (!length(rows)) return(dg[0, , drop = FALSE])
    dplyr::bind_rows(rows) |> dplyr::distinct()
  }

  if (is.null(group_var)) {
    build_for_group(df)
  } else {
    df |>
      dplyr::group_split(.data[[group_var]], .keep = TRUE) |>
      lapply(build_for_group) |>
      dplyr::bind_rows()
  }
}

# ----- Helpers ---------------------------------------------------------------

# Build a COMPLETE set of dummy rows so that every ordinal variable
# has ALL its categories represented in each chunk.
# - Single-group: one template row taken from data; for each ov.ord variable,
#   create one row per category (using levels() if factor, otherwise unique()).
# - Multi-group: do the same **per group** and ensure at least one row per group.
create_dummy_from_original <- function(dat_original, ov_ord, group_var = NULL) {
  # Nothing to do
  if (length(ov_ord) == 0L) return(dat_original[0, , drop = FALSE])

  ov_ord <- ov_ord[ov_ord %in% names(dat_original)]
  if (length(ov_ord) == 0L) return(dat_original[0, , drop = FALSE])

  # Helper: for a given data frame and one ordinal variable name,
  # produce rows covering ALL categories for that variable.
  build_rows_for_var <- function(df, var) {
    proto <- df[1, , drop = FALSE]  # template row with correct classes
    x     <- df[[var]]

    # Categories: prefer levels() if factor; otherwise distinct observed values
    cats <- if (is.factor(x)) levels(x) else sort(unique(x))

    # If no categories (all NA), return 0-row df with same cols
    if (length(cats) == 0L) return(df[0, , drop = FALSE])

    # Build one row per category, casting the value to the same type as column x
    rows <- lapply(cats, function(cat) {
      r <- proto
      r[[var]] <- .cast_like(cat, x)
      r
    })
    dplyr::bind_rows(rows)
  }

  if (is.null(group_var)) {
    # -------- SINGLE-GROUP --------
    if (nrow(dat_original) == 0L) return(dat_original[0, , drop = FALSE])

    parts <- lapply(ov_ord, function(v) build_rows_for_var(dat_original, v))
    dummy <- dplyr::bind_rows(parts) |> dplyr::distinct()
    if (nrow(dummy) == 0L) dummy <- dat_original[0, , drop = FALSE]
    return(dummy)
  } else {
    # -------- MULTI-GROUP --------
    if (!group_var %in% names(dat_original)) {
      stop("Group column '", group_var, "' not found in data supplied to create_dummy_from_original().")
    }
    if (nrow(dat_original) == 0L) return(dat_original[0, , drop = FALSE])

    dummy_list <- dat_original |>
      dplyr::group_split(.data[[group_var]], .keep = TRUE) |>
      lapply(function(df_g) {
        parts_g <- lapply(ov_ord, function(v) build_rows_for_var(df_g, v))
        base_g  <- df_g |> dplyr::slice_head(n = 1)
        dplyr::bind_rows(base_g, parts_g) |> dplyr::distinct()
      })

    dummy <- dplyr::bind_rows(dummy_list)

    # Guarantee at least one row per group
    have_groups <- unique(dummy[[group_var]])
    missing_g   <- setdiff(unique(dat_original[[group_var]]), have_groups)
    if (length(missing_g)) {
      add <- dat_original |>
        dplyr::group_by(.data[[group_var]]) |>
        dplyr::filter(.data[[group_var]] %in% missing_g) |>
        dplyr::slice_head(n = 1) |>
        dplyr::ungroup()
      dummy <- dplyr::bind_rows(dummy, add)
    }

    dplyr::distinct(dummy)
  }
}
