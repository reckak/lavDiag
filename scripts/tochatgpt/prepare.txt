#' The goal is to avoid any manual manipulation of factor-score data or group columns.
#' All such handling is delegated to the respective sub-functions to minimize edge-case issues.
#'
#' @param fit A fitted lavaan/blavaan object.
#' @param data Optional pre-computed factor-score data; passed to sub-functions unchanged.
#' @param info Optional `model_info()` list; if `NULL`, it will be computed and forwarded.
#' @param plan Future plan for the ordinal branch; forwarded to `prepare_ordinal()`.
#' @param ... Additional arguments forwarded unchanged to both sub-functions (e.g.,
#'   `level`, `vcov_type`, `length.out`, `other_latents`, `latent_var_as_factor`,
#'   `se`, `se_summary`, etc.).
#' @return A tibble: either a single output (if the other is not applicable),
#'   or their `dplyr::full_join()` based on shared ID columns when available, otherwise
#'   on the full intersection of columns.
#' @export
prepare <- function(fit,
                    data = NULL,
                    info = NULL,
                    plan = c("auto","none","multisession","multicore","sequential","cluster"),
                    workers = NULL,
                    cluster = NULL,
                    ...) {
  plan <- match.arg(plan)

  # Parallel args sanitization
  if (!identical(plan, "cluster")) {
    cluster <- NULL
  } else if (!is.null(cluster) && !inherits(cluster, "cluster")) {
    warning("'cluster' is not a valid parallel::makeCluster() object - ignoring.")
    cluster <- NULL
  }
  is_worker <- FALSE
  try({ is_worker <- inherits(future::current_scheduler(), "Scheduler") && !future::onLocalHost() }, silent = TRUE)
  if (isTRUE(is_worker)) {
    plan <- "sequential"; cluster <- NULL; workers <- NULL
  }

  # Model info
  if (is.null(info)) info <- model_info(fit)
  eta_cols <- info$latent_variables

  # Branches
  p_cont <- tryCatch(
    .prepare_continuous(fit, data = data, info = info, ...),
    error = function(e) NULL
  )
  p_ord <- tryCatch(
    .prepare_ordinal(fit, data = data, info = info,
                     plan = plan, workers = workers, cluster = cluster, ...),
    error = function(e) NULL
  )

  if (is.null(p_cont) && is.null(p_ord)) {
    rlang::abort("Neither continuous nor ordinal branch succeeded - check model/functions.")
  }
  if (is.null(p_cont)) return(p_ord)
  if (is.null(p_ord))  return(p_cont)

  # Keep canonical factor-score columns (A, E, ...) only from the continuous branch
  if (length(eta_cols)) {
    p_ord <- dplyr::select(p_ord, -dplyr::any_of(eta_cols))
  }

  # Join
  id_candidates <- c(".rid", ".gid", ".group", ".latent_var")
  ids_cont <- intersect(id_candidates, colnames(p_cont))
  ids_ord  <- intersect(id_candidates, colnames(p_ord))
  by_ids   <- intersect(ids_cont, ids_ord)
  by <- if (length(by_ids)) by_ids else intersect(colnames(p_cont), colnames(p_ord))

  out <- if (!length(by)) {
    rlang::warn("Continuous and ordinal outputs have no shared columns - returning row bind.")
    dplyr::bind_rows(p_cont, p_ord, .id = ".source")
  } else {
    # With latent columns removed from p_ord, no A.x/E.y suffixes will be created
    dplyr::full_join(p_cont, p_ord, by = by)
  }

  id_front <- intersect(c(".rid", ".gid", ".group", ".latent_var"), colnames(out))
  if (length(id_front)) out <- dplyr::relocate(out, dplyr::all_of(id_front))
  out
}
